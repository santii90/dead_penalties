--[[
Death penalties is inspired by EFT, where you lose all your gear when you die.
The idea is to put together a hideout with some extra weapons and gear,
still you'll have the opportunity of getting some of your gear back if you return (and survive) to the place where you died.
You'll lose a % of money and also equipped items will lose condition when you drop them.


I used Minecraft_Respawn code as a baseline for the project, so thanks to RavenAscendant for that.
https://www.moddb.com/mods/stalker-anomaly/addons/minecraft-respawn
--]] local max_money_percentage
local max_money_to_drop_percentage
local max_condition_lose
local min_condition_lose
local enable_time_forward
local sleep = {
    level = false,
    position = false,
    level_vert = false,
    game_vert = false,
    dead = false,
    stash_created = false,
    sleep_created = false
}
local fullHealChance = 10
local fullSatietyChance = 25 -- %Chance for player to not have any hunger after death
local mealChance = 0.35 -- %Chance for meals, calculation still in very early stages, max value is 1!!
local currently_respawning = nil
local last_death_time = 0
local respawn_done = false
local global_healing = 1
local global_satiety = 1
local global_power = 1

function load_settings()
    max_money_percentage = Dead_penalties_mcm.get_config("max_money_percentage")
    max_money_to_drop_percentage = Dead_penalties_mcm.get_config("max_money_to_drop_percentage")
    max_condition_lose = Dead_penalties_mcm.get_config("max_condition_lose")
    min_condition_lose = Dead_penalties_mcm.get_config("min_condition_lose")
    enable_time_forward = Dead_penalties_mcm.get_config("enable_time_forward")
end

function on_game_start()
    RegisterScriptCallback("on_option_change", load_settings)
    RegisterScriptCallback("on_game_load", load_settings)
    local ini_stash = ini_file("items\\settings\\backpack_stash.ltx")
    keep_items = utils_data.collect_section(ini_stash, "actor_backpack_keep_items", true)
    RegisterScriptCallback("actor_on_before_death", actor_on_before_death)
    RegisterScriptCallback("actor_on_sleep", actor_on_sleep)
    RegisterScriptCallback("save_state", save_state)
    RegisterScriptCallback("load_state", load_state)
    RegisterScriptCallback("actor_on_stash_create", actor_on_stash_create)
    RegisterScriptCallback("actor_on_stash_remove", actor_on_stash_remove)
    RegisterScriptCallback("on_game_load", on_game_load)
end

function on_game_load()
    UnregisterScriptCallback("actor_on_before_death", actor_on_before_death)
    RegisterScriptCallback("actor_on_before_death", actor_on_before_death)
    if sleep.dead then
        sleep.dead = false
        bind_stalker_ext.invulnerable_time = time_global() + 30000
        gamemode_azazel.heal_everything()

        -- Transition
        level.add_pp_effector("deimos1.ppe", 210410, false)
    end
end

function print_dbg(text, ...)
    if true then
        printf("RAX: | %s |  " .. text, time_global(), ...)
    end
end

function actor_on_before_death(who, flags)
    local current_time = time_global()
    if not (sleep.level and sleep.position.x and sleep.position.y and sleep.position.z) then
        print_dbg("SLEEP enter tele %s| %s %s %s |%s %s", sleep.level, sleep.position.x, sleep.position.y,
            sleep.position.z, sleep.level_vert, sleep.game_vert)
        return
    end
    print_dbg("actor_on_before_death %s")

    -- bind_stalker_ext.invulnerable_time = time_global() + 10000
    -- bind_stalker_ext.respawn_invulnerable_time = time_global() + 10000
    print_dbg("actor_on_before_death previous %s", last_death_time)
    if last_death_time < current_time then
        last_death_time = current_time + 10000
        respawn_done = false
    end
    print_dbg("time_global %s", current_time)
    print_dbg("is last_death_time < time_global %s", last_death_time < current_time)
    print_dbg("last_death_time %s", last_death_time)
    -- db.actor:set_health_ex(1)
    if last_death_time > current_time and not respawn_done then
        print_dbg("entro IF")
        level.disable_input()
        get_console():execute("hud_draw off")
        respawn_done = true
        db.actor:set_health_ex(1)
        if not currently_respawning then
            print_dbg("currently_respawning if NOT %s", currently_respawning)
            drop_stash()
            currently_respawning = 1
        end
        --- Forward Time ---
        local forwardTimeMinHours = 1
        local forwardTimeMaxHours = 36
        local p = {}
        p[1] = math.random(forwardTimeMinHours, forwardTimeMaxHours)
        p[2] = math.random(0, 59)
        -- Heal player--
        local healing = 0.25
        local satiety = 1
        local mealVal = 0.1
        local satiety_minus_per_hour = 0.02
        local power = math.random(3, 10) / 10
        if math.random(1, 100) <= fullHealChance then
            healing = 1
        else
            -- Heal player depending on how much time was spent being down/knocked out
            healing = healing + (0.007 * p[1]) + (0.00011 * p[2])
        end
        if healing > 1 then
            healing = 1
        end
        -- Satiety calculation--
        if math.random(1, 100) <= fullSatietyChance then
            satiety = 1
        else
            -- Logic: actor can get a meal every 6 hours 
            if satiety_minus_per_hour * p[1] >= satiety then
                satiety = 0.2
            else
                satiety = satiety - (satiety_minus_per_hour * p[1])
            end
            local additionalFood = math.random(1, 80) / 1000
            local totalFood = p[1] / 6
            local foodWithChance = totalFood * mealChance
            satiety = satiety + (foodWithChance * mealVal) + additionalFood
            if satiety > 1 then
                satiety = 1
            elseif satiety < 0.2 then
                satiety = 0.2
            end
        end

        if currently_respawning == 1 then
            print_dbg("currently_respawning if 1 %s", currently_respawning)
            -- set_health()
            -- forward_time(p)
            teleport()

            currently_respawning = 2
        end

        if currently_respawning == 2 then
            print_dbg("currently_respawning if 2 %s", currently_respawning)
            if enable_time_forward then
                xr_effects.forward_game_time(nil, nil, p)
                -- level.change_game_time(0, p[1], 0)
                local forward_text = tostring("You have been out of action for " .. p[1] .. " Hours and " .. p[2] ..
                                                  " Minutes")
                db.actor:give_game_news("Severe Injured", forward_text, "ui_inGame2_neutral_2_mask", 0, 20000)
            end
            currently_respawning = 3
        end

        if currently_respawning == 3 then
            currently_respawning = 4
            print_dbg("currently_respawning if 3 %s", currently_respawning)
            
            bind_stalker_ext.respawn_new_health = healing
            global_healing = healing
            global_satiety = satiety
            global_power = power

            currently_respawning = nil
        end
        get_console():execute("hud_draw on")
        level.enable_input()
    end
    print_dbg("healing %s", global_healing)
    print_dbg("power %s", global_power)
    print_dbg("satiety %s", global_satiety)
    -- db.actor.health = global_healing
    db.actor:set_health_ex(global_healing)
    db.actor.bleeding = 1
    db.actor.psy_health = 1
    db.actor.radiation = 0
    db.actor.satiety = global_satiety
    db.actor.power = global_power
    print_dbg("actor satiety %s", db.actor:cast_Actor():conditions():GetSatiety())
    arszi_psy.set_psy_health(1)
    print_dbg("db.actor.health %s", db.actor.health)
    flags.ret_value = false
end

keep_items = nil

function drop_stash()
    sleep.dead = true
    local actor = db.actor
    local se_obj = alife_create("inv_backpack", actor:position(), actor:level_vertex_id(), actor:game_vertex_id())
    local ignore_items = {
        ["device_pda_1"] = true,
        ["device_pda_2"] = true,
        ["device_pda_3"] = true,
        ["detector_simple"] = true
    }
    if (se_obj) then
        local txt = strformat(game.translate_string("st_itm_stash_of_character"), db.actor:character_name())
        level.map_add_object_spot_ser(se_obj.id, "treasure", txt)
        actor_menu.set_msg(1, game.translate_string("st_stash_created"), 4)

        local m_data = alife_storage_manager.get_state()
        if not (m_data.player_created_stashes) then
            m_data.player_created_stashes = {}
        end

        m_data.player_created_stashes[se_obj.id] = itm_backpack

        -- Lose money
        local current_money = actor:money()
        local money_to_lose = math.random(0, math.floor(current_money * max_money_percentage))
        db.actor:give_money(-money_to_lose)

        local denominations = {{
            name = "money_1000",
            value = 1000
        }, {
            name = "money_100",
            value = 100
        }, {
            name = "money_10",
            value = 10
        }}

        local money_left = math.random(0, math.floor(money_to_lose * max_money_to_drop_percentage))

        for _, denom in ipairs(denominations) do
            local num_items_to_create = math.floor(money_left / denom.value)
            money_left = money_left % denom.value
            for i = 1, num_items_to_create do
                alife_create_item(denom.name, se_obj)
            end
        end

        print_dbg("Total money to lose: " .. money_to_lose)

        local function transfer_items(id)
            local obj = level.object_by_id(id)
            if (obj) then
                local function itr_inv(temp, item)
                    -- print_dbg("item: %s", item:section())
                    if not (ignore_items[item:section()]) then
                        if (item and item:id() ~= b_id and keep_items[item:section()] == nil) then
                            -- if (IsAmmo(item) ~= true) or (item_backpack.is_ammo_for_wpn(item:section()) ~= true) then
                            if (ini_sys:r_bool_ex(item:section(), "quest_item", false) == false) then
                                if (item_backpack.is_in_slot(item) == true) then
                                    -- if item is in slot get current item:condition() and reduce it randomly between 2% and 20%
                                    local condition = item:condition()
                                    local condition_reduction =
                                        math.random(min_condition_lose, max_condition_lose) / 100
                                    condition = condition - condition_reduction
                                    if (condition < 0) then
                                        condition = 0
                                    end
                                    item:set_condition(condition)
                                    db.actor:transfer_item(item, obj)
                                else
                                    db.actor:transfer_item(item, obj)
                                end
                            end
                            -- end
                        end
                    end
                end
                print_dbg("SLEEP before itr_inv")
                db.actor:iterate_inventory(itr_inv)
                -- teleport()
                return true
            end
            return false
        end
        print_dbg("SLEEP before event")
        CreateTimeEvent("RAX SleepSpawn", "actor_backpack", 0, transfer_items, se_obj.id)
    end
end

function forward_time(p)
    if enable_time_forward then
        xr_effects.forward_game_time(nil, nil, p)
        local forward_text = tostring("You have been out of action for " .. p[1] .. " Hours and " .. p[2] .. " Minutes")
        db.actor:give_game_news("Severe Injured", forward_text, "ui_inGame2_neutral_2_mask", 0, 20000)
    end
end

function set_health()
    db.actor.health = 0.7
    db.actor.bleeding = 1
    db.actor.psy_health = 1
    db.actor.radiation = 0
    db.actor.satiety = 0.8
    db.actor.power = 1.0
end

function teleport()
    print_dbg("SLEEP enter tele %s| %s %s %s |%s %s", sleep.level, sleep.position.x, sleep.position.y, sleep.position.z,
        sleep.level_vert, sleep.game_vert)
    if sleep.level and sleep.position and sleep.level_vert and sleep.game_vert then
        print_dbg("SLEEP enter tele1")
        if (sleep.level == level.name()) then
            print_dbg("SLEEP enter tele2")
            -- Heal
            -- gamemode_azazel.heal_everything()
            -- Forward Time
            -- forward_time()
            -- Transition
            level.add_pp_effector("deimos1.ppe", 210410, false)

            db.actor:set_actor_position(sleep.position)
            sleep.dead = false
        else
            print_dbg("SLEEP enter tele3")
            ChangeLevel(sleep.position, sleep.level_vert, sleep.game_vert, VEC_ZERO, true)
        end

    end
    return true
end

function save_position(stash_data)
    pos = db.actor:position()
    print_dbg("SAVE POSITION %s| %s %s %s |", level.name(), pos.x, pos.y, pos.z)
    sleep.level = level.name()
    sleep.posX = pos.x
    sleep.posY = pos.y
    sleep.posZ = pos.z
    sleep.position = vector():set(sleep.posX or 0, sleep.posY or 0, sleep.posZ or 0)
    sleep.level_vert = db.actor:level_vertex_id()
    sleep.game_vert = db.actor:game_vertex_id()
    if stash_data then
        level.map_add_object_spot_ser(stash_data.stash_id, "ui_pda2_actor_sleep_location", "Respawn")
    end
end

function actor_on_sleep()
    if sleep.stash_created == false then
        print_dbg("SET POSITION on SLEEP")
        sleep.sleep_created = true;
        save_position()
    end
end

function actor_on_stash_create(data)
    print_dbg("SET POSITION on STASH CREATE %s", data.stash_id)
    sleep.stash_created = true;
    save_position(data)
end

function actor_on_stash_remove()
    sleep.stash_created = false;
    print_dbg("STASH REMOVED, stash_created = %s", sleep.stash_created)
end

-- NOT WORKING, NEED TO FIGURE OUT ANOTHER APPROACH
function actor_on_save()
    print_dbg("ON SAVE | %s %s", sleep.stash_created, sleep.sleep_created)
    if sleep.stash_created == false and sleep.sleep_created == false then
        print_dbg("SET POSITION on SAVE")
        save_position()
    end
end

function save_state(mdata)
    mdata.RAX_sleep_location = sleep

end

function load_state(mdata)
    sleep = mdata.RAX_sleep_location or sleep
    sleep.position = vector():set(sleep.posX or 0, sleep.posY or 0, sleep.posZ or 0)
end
